class Solution {
    /*
     * 这道题让我们求同构字符串，就是说原字符串中的每个字符可由另外一个字符替代，可以被其本身替代，相同的字符一定要被同一个字符替代，且一个字符不能被多个字符替代，即不能出现一对多的映射。根据一对一映射的特点，我们需要用两个哈希表分别来记录原字符串和目标字符串中字符出现情况，由于ASCII码只有256个字符，所以我们可以用一个256大小的数组来代替哈希表，并初始化为0，我们遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找其值，若不相等，则返回false，若想等，将其值更新为i + 1，
     
     注意这道题自己刚开始理解错了，其实Isomorphic Strings只是要求同构字符串，其中也就是说字符保证一致的映射关系即可，如果字符A从串S映射到串T的B字符，那么这种映射需要一直成立，同时别的在串S中的字符不能再映射到B。这就叫做preserving the order of characters。
     
     我想的序的概念更复杂了，我理解的题意是“映射后字母出现的‘相对顺序’要保持”， 比如Given "paper", "title"， 我就没想明白为什么这个是同构字符串，因为我想的paper里面r是比前面字母都靠后的一个字母（从字母顺序表的26个字符来说），而title里面r被映射成了e,明显e比其他titl都要在字母表里面靠前，所以我开始以为题是错的。
     
     最后理解了同构字符串的定义后，基本上就是要判断是不是有一致的映射关系即可。
     */
public boolean isIsomorphic(String sString, String tString) {

        char[] s = sString.toCharArray();
        char[] t = tString.toCharArray();

        int length = s.length;
        if(length != t.length) return false;

        int[] sm = new int[256];//记录S串中每个字符映射到的地方
        int[] tm = new int[256];//记录T串中每个字符映射到的地方

        for (int i = 0; i < length; ++i) {
            if (sm[s[i]] != tm[t[i]]) return false;
            sm[s[i]] = i+1; //让他们都影射为一个数即可，但是不能映射到0，因为sm,tm内部所有初始化的值都是0，所以这里不能影射到一个初始化的值，那么最简单的让其映射到一个非零的数即可，比如i+1，其实这里随便写i+53也行.
            tm[t[i]] = i+1; //只要保证两个数应该成为一样的就可以！！ 
            
            //上面是把s[i] t[i]都映射成为了一个第三方的数，其实也可以直接在映射表里将其两者直接建立起映射
        }
 
        return true;
}
