/*思路： 比较难的一题，很难想到用二分法。已知要求的值肯定在最大的单个数字与所有数组求和的值之间（我们首先来分析，如果m和数组nums的个数相等，那么每个数组都是一个子数组，所以返回nums中最大的数字即可，如果m为1，那么整个nums数组就是一个子数组，返回nums所有数字之和，所以对于其他有效的m值，返回的值必定在上面两个值之间，）。这样可以在这个区间用二分法来探测，每次给定一个mid，如果能找出相应的划分使得每个子序列和尽可能大且不超过mid且子序列总个数小于等于m，则说明给定的给定的mid目标太大了，那么就继续左移，让mid=right，把目标定的继续比当前值低.否则如果找出来的结果发现mid定的太小，以至于划分出来的子序列个数大于m个了（因为可能mid值太低，每个子序列不能包含过多的元素，所以总的子序列个数就变多了），就说明mid太小了，就往右移。就这样找下去知道退出循环，返回左子针所指元素的int部分即可。


本题可以使用二分答案的方法来做。要求这个最小值是比较难的，但是给定一个值x，判断是否存在一种划分使得每个子区间的和都不超过x，这是容易的。我们可以贪心地遍历一遍数组，不断求和，直到和超过了x值，再新分出一个子区间，最后检查划分出的子区间数是否超过了m。这个检查的时间复杂度为O(n). 
　　然后就可以不断的询问x是否满足上述条件，如果满足说明我们要求的解不超过x，否则说明要求的解大于x，这就构成了一个二分的条件。我们先猜测x属于一个足够大的范围，然后检查中间值是否满足条件，不管结果如何，我们都可以将猜测区间减半。如此不断的缩减区间，就得到了最后的解。因为int的值不超过2^31，所以需要O(log(2^31))=O(1)次检测，因此算法复杂度是O(n)的。

我们首先来分析，如果m和数组nums的个数相等，那么每个数组都是一个子数组，所以返回nums中最大的数字即可，如果m为1，那么整个nums数组就是一个子数组，返回nums所有数字之和，所以对于其他有效的m值，返回的值必定在上面两个值之间，所以我们可以用二分搜索法来做。我们用一个例子来分析，nums = [1, 2, 3, 4, 5], m = 3，我们将left设为数组中的最大值5，right设为数字之和15，然后我们算出中间数为10，我们接下来要做的是找出和最大且小于等于10的子数组的个数，[1, 2, 3, 4], [5]，可以看到我们无法分为3组，说明mid偏大，所以我们让right=mid，然后我们再次进行二分查找哦啊，算出mid=7，再次找出和最大且小于等于7的子数组的个数，[1,2,3], [4], [5]，我们成功的找出了三组，说明mid还可以进一步降低，我们让right=mid，然后我们再次进行二分查找哦啊，算出mid=6，再次找出和最大且小于等于6的子数组的个数，[1,2,3], [4], [5]，我们成功的找出了三组，我们尝试着继续降低mid，我们让right=mid，然后我们再次进行二分查找哦啊，算出mid=5，再次找出和最大且小于等于5的子数组的个数，[1,2], [3], [4], [5]，发现有4组，此时我们的mid太小了，应该增大mid，我们让left=mid+1，此时left=6，right=5，循环退出了，我们返回left即可，参见代码如下：*/

public class Solution {
    public int splitArray(int[] nums, int m) {
        int max = 0; long sum = 0;
        for (int num : nums) {
            max = Math.max(num, max);
            sum += num;
        }
        if (m == 1) return (int)sum;
        //binary search
        long l = max; long r = sum;
        while (l <= r) {
            long mid = (l + r)/ 2; //注意这里mid用long类型
            if (valid(mid, nums, m)) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return (int)l; //返回l的整形部分
    }

//这个函数就是判断给定target,划分子序列，使得每个子序列的和不超过target,然后判断这样的子序列的个数是不是超过m,超过返回false, 否则返回True
    public boolean valid(long target, int[] nums, int m) {
        int count = 1;
        long total = 0;
        for(int num : nums) {
            total += num;
            if (total > target) {
                total = num; //一旦当前和超过了taret, 那么就归零，重新开始一个子序列，其第一个元素就是当前的num,其作为第一个值
                count++;
                if (count > m) {
                    return false;
                }
            }
        }
        return true;
    }
}
