/* 九章采用位操作的方法，借助异或操作符，如果两个数字都出现的话，总会把他们加起来的，那么总会最后对应位都是0的。
位异或：第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n为也为1，否则为0

就对数组里每个数一直积累做异或操作，最后剩下的那个数，必定就是无法通过异或归为0的数。很巧。

自己想到的是先排序，然后临近两个比较的方法，其实这是不符合题意的，因为排序就不是Linear的复杂度了，注意。


*/

 public int singleNumber(int[] A) {
        if(A == null || A.length == 0) {
            return -1;
        }
        int rst = 0;
        for (int i = 0; i < A.length; i++) {
            rst ^= A[i];
        }
        return rst;
    }
