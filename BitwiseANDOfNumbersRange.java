
/*
思路： 假如说5:101  7:111  连续几个数相与的规律：一，只要是相同的位置的数字不相同最后那个位置的结果一定是0 。二，如果高位不相同，从不相同的那位到最低位都会为0，例如5和7虽然第0位相同但是由于第一位不相同，所以最后结果第0位 和第一位都为0。  

如果理解了第二个规律就好办了，如果两个数位数不相同肯定最后结果为0。如果两个数位数相同，从最高位开始寻找，将第一次发现不相同的那一位到最低位都置为0，其实就是找两个数最left的公共部分；


代码中，通过不断地右移直到两个数字相等，然后再左移相同的位数，这样做的效果其实就是将位置不相同的都置为0

 bin     dec
 101       5
 110       6
 111       7
-------------
 100       4

*/
 public int rangeBitwiseAnd(int m, int n) {
        if (m == 0) return 0;
        int moveFactor = 1;
        while (m != n) {
            m >>= 1;
            n >>= 1;
            moveFactor <<= 1;
        }
        return m * moveFactor;
    }
