/*
思路：对树的理解，也可以用Stack来做，但是用出度入度方法更有效。

在二叉树中，如果我们将空节点视为叶子节点，那么除根节点外的非空节点（分支节点）提供2个出度（切合到本题，因为我们也用#表示了一个空节点并把它当作叶子节点，那么对于一个非空节点之外，它总有2个出度）和1个入度（2个孩子和1个父亲）

所有的空节点提供0个出度和1个入度（0个孩子和1个父亲）

假如我们尝试重建这棵树。在构建的过程中，记录出度与入度之差，记为diff = outdegree - indegree

当遍历节点时，我们令diff - 1（因为不管是非空节点，还是空节点，它们提供了一个入度）。如果节点非空，再令diff + 2（因为非空节点提供了2个出度）

如果序列化是正确的，那么diff在任何时刻都不会小于0，并且最终结果等于0

对该算法的一个朴素理解（2016-06-08增补）：

如果在遍历过程中的某时刻，系统的入度>出度，则说明当前序列中出现过的所有分支节点的“空闲分支”均已用完，后序节点没有办法挂载到之前出现的节点之上，从而判定先序遍历的序列是不合法的。
*/

public boolean isValidSerialization(String preorder) {
    String[] nodes = preorder.split(",");
    int diff = 1;
    for (String node: nodes) {
        if (--diff < 0) return false; //每个节点都会使diff减1， 另外，随时判断当前diff是不是<0
        if (!node.equals("#")) diff += 2; //每个非空节点使得diff增加2，因为其贡献2个出度
    }
    return diff == 0;
}
